# JUC高并发

### JUC含义
- java.util.concurrent
- java.util.concurrent.atomic
- java.util.concurrent.locks
> 指代这三个包，主要用于并发编程

### volatile与
#### volatile是Java虚拟机提供的轻量级的同步机制
- 保证可见性
- 不保证原子性
- 禁止指令重排
> 保证了1、3但不保证原子性，因此是轻量级的同步机制

#### JMM(java内存模型，Java Memory Model)
&emsp;&emsp;本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实体字段，静态字段和构成数组对象的元素)的访问方式
JMM关于同步的规定：
- 线程解锁前，必须把共享内存的值刷回主内存
- 线程加锁前，必须读取主内存的最新值到自己的工作内存
- 加锁解锁是同一把锁

JMM一般要求数据保证三个特性
- 可见性
- 原子性
- 有序性

### CAS
底层原理: 自旋锁、Unsafe类
Unsafe类+CAS思想(自旋)
CAS --> Unsafe --> CAS底层思想 --> ABA --> 原子引用更新 --> 如何规避ABA问题
#### Unsafe
&emsp;&emsp;是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe相当于一个后门，给予该类可以直接
操作特定内存的数据。Unsafe类存在与sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖
与Unsafe类的方法
> 注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务
缺点：cup资源消耗、ABA问题



#### ABA问题
一句话：狸猫换太子
CAS会导致"ABA问题"

> CAS实现的一个重要前提，需要去除内存中某时刻的数据，并在当下时刻比较并替换，那么在这个时间差内会导致数据的变化。

&emsp;&emsp;例如线程one从内存位置V取出数据A，同时线程two也从内存中取出A并作出操作将值变为B，然后线程B又将位置V的数据改回A，
此时线程one进行CAS操作发现内存中V位置的值依然是A，线程one操作成功。

*尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的*

#### 解决ABA问题
CAS不够
原子引用 AtomicReference类实现
理解原子引用 + 新增一种机制：修改版本号(类似时间戳) AtomicStampedReference类实现

#### Java中的锁
##### 公平锁 
多个线程按照申请顺序来获取锁，先来后到

##### 非公平锁 
多个线程不是按照申请顺序来获取锁，有可能后申请的线程比先申请的线程先获取到锁
在高并发的情况下，有可能造成优先级反转或饥饿现象
> synchronized是非公平锁

#####   可重入锁(又名递归锁)
指同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，
在同一线程外层方法获取锁的时候，再进入内层方法会自动获取锁
即线程可以进入任何一个它已经拥有的锁同步着的代码块
ReentrantLock/Synchronized 就是典型的可重入锁
> 最大的作用是防止死锁

##### 自旋锁
指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文的消耗，
缺点是循环会消耗cpu

##### 读写锁
- 独占锁(写锁) 指锁一次只能被一个线程锁持有。ReentrantLock/Synchronized 都是独占锁
- 共享锁(读锁) 指锁可被多个线程所持有 ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁
- 互斥锁 读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的































